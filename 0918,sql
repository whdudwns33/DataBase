-- Group by: 여러 데이터에서 의미 있는 하나의 결과를 특정 열 값으로 묶어서 출력
-- 전체 평균
SELECT ROUND(AVG(SAL), 2) 
FROM EMP;

-- 부서별 평균
SELECT DEPTNO, ROUND(AVG(SAL), 2)
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;

-- GROUP BY 절 없이 구현한다면?
SELECT ROUND(AVG(SAL), 2) FROM EMP WHERE DEPTNO = 10;
SELECT ROUND(AVG(SAL), 2) FROM EMP WHERE DEPTNO = 20;
SELECT ROUND(AVG(SAL), 2) FROM EMP WHERE DEPTNO = 30;

-- 집합 연산자를 사용하여 구현
SELECT AVG(SAL)FROM EMP WHERE DEPTNO = 10
UNION ALL
SELECT AVG(SAL)FROM EMP WHERE DEPTNO = 20
UNION ALL
SELECT AVG(SAL)FROM EMP WHERE DEPTNO = 30;

-- 부서코드, 급여합계, 부서 평균, 부서 코드 순 정렬
SELECT DEPTNO 부서코드, SUM(SAL) 합계, ROUND(AVG(SAL)) 평균, COUNT(*) 총인원
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO ASC;

-- HAVING 절: GROUP BY 절이 존재할 떄만 사용 가능
-- GROUP BY 절을 통해 그룹화된 결과 값의 번위를 제한할 때 사용
-- 먼저 부서별, 직책별 그룹화하여 평균을 구함
-- 그다음에 각 그룹의 급여 평균이 2000이 넘는 결과 출력
SELECT DEPTNO, JOB, ROUND(AVG(SAL),2)
FROM EMP
GROUP BY DEPTNO, JOB    -- 부서별로 묶고 거기에 직업으로 한번더 나눔
HAVING AVG(SAL) >= 2000     -- 평균은 2000이상의 급여로 
ORDER BY DEPTNO, JOB;

-- WHERE
-- 먼저 급여가 2000이 넘는 사원들을 구분
-- 조건에 맞는 사원중에서 부서별, 직책별 급여의 평균을 구해서 출력
SELECT DEPTNO, JOB, ROUND(AVG(SAL),2)
FROM EMP
WHERE AVG(SAL) >= 2000
GROUP BY DEPTNO, JOB    -- 부서별로 묶고 거기에 직업으로 한번더 나눔
ORDER BY DEPTNO, JOB;



-- 예제: 
-- 1. 부서별 직책의 평균 급여가 500이상인 사원들의 부서 번호, 직책, 부서별 직책의 평균 급여
SELECT DEPTNO, JOB, ROUND(AVG(SAL),2)
FROM EMP
GROUP BY DEPTNO, JOB
HAVING ROUND(AVG(SAL),2) >= 500;
-- 2. EMP 테이블을 이용하여 부서번호, 평균급여, 최고급여, 최저급여, 사원수를 출력,
--   단, 평균 급여를 출력 할 때는 소수점 제외하고 부서 번호별로 출력
SELECT DEPTNO, TRUNC(AVG(SAL)), MAX(SAL), MIN(SAL), COUNT(*)
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;
-- 3. 같은 직책에 종사하는 사원이 3명 이상인 직책과 인원을 출력
SELECT JOB, COUNT(*)
FROM EMP
GROUP BY JOB
HAVING COUNT(JOB) >= 3;
-- 4. 사원들의 입사 연도를 기준으로 부서별로 몇 명이 입사했는지 출력
SELECT TO_CHAR(HIREDATE, 'YYYY'), DEPTNO, COUNT(*)
-- EXTRACT(YEAR FROM HIREDATE)
FROM EMP
GROUP BY TO_CHAR(HIREDATE, 'YYYY'), DEPTNO;

-- 5. 추가 수당을 받는 사원 수와 받지 않는 사원수를 출력 (O, X로 표기 필요)
SELECT NVL2(COMM, 'O', 'X'), COUNT(*)
FROM EMP
GROUP BY NVL2(COMM, 'O', 'X');

-- 6. 각 부서의 입사 연도별 사원 수, 최고 급여, 급여 합, 평균 급여를 출력
SELECT DEPTNO, TO_CHAR(HIREDATE, 'YYYY'), MAX(SAL), SUM(SAL), ROUND(AVG(SAL), 2), COUNT(*)
FROM EMP
GROUP BY DEPTNO, TO_CHAR(HIREDATE, 'YYYY')
ORDER BY DEPTNO, TO_CHAR(HIREDATE, 'YYYY');

-- 그룹화와 관련된 여러 함수: ROLLUP, CUBE..

-- ### ROLLUP 함수를 적용한 그룹화
-- **명시한 열을 소그룹부터 대그룹의 순서로 각 그룹별 결과를 출력하고 
-- 마지막에 총 데이터 결과를 출력** 합니다.
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), ROUND(AVG(SAL))
FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB);






-- 조인 : 두개 이상의 테이블에서 데이터를 가져와 연결하는 데 사용하는 SQL의 기능
-- RDMS에서는 테이블 설계시 무결성 원칙으로 인해 동일한 정보가 여러 군데 존재하면 안되기 때문에
-- 필연적으로 테이블을 관리 목적에 맞게 설계 함.
SELECT *
FROM DEPT; -- 부서 정보를 저장하는 테이블. DEPTNO는 부서 테이블의 참조 키(열)

SELECT * 
FROM EMP, DEPT;     -- 카테시안의 곱

-- 열 이름을 비교하는 조건식으로 조인하기
SELECT *  
    FROM EMP, DEPT
    WHERE EMP.DEPTNO = DEPT.DEPTNO  --기준 열 DEPTNO 결정. 외래키
ORDER BY EMPNO;

-- 테이블 별칭 사용하기 
SELECT *    -- 4
    FROM EMP E, DEPT D  -- 1: 연결
    WHERE E.DEPTNO = D.DEPTNO   -- 2
ORDER BY EMPNO;     -- 3

-- 조인 종류: 두 개 이상의 테이블을 하나의 테이블처럼 가로로 늘려서 출력하기 위해서 사용
-- 조인은 대상 데이터를 어떻게 연결하느냐에 따라 등가, 조인, 비등가, 자체 외부 조인으로 구분
-- 등가 조인: 테이블을 연결하는 후 출력 행을 각 테이블의 특정열에 일치한 데이터를 기준으로 선정하는 방식
-- 등가 조인에는 안시(ANSI) 조인과 오라클 조인이 있음
-- 오라클 조인  
SELECT EMPNO, ENAME, D.DEPTNO, DNAME, LOC
    FROM EMP E, DEPT D
    WHERE E.DEPTNO = D.DEPTNO
    AND E.DEPTNO = 10
    ORDER BY D.DEPTNO;
-- 급여가 3000 이상인 조건
SELECT SAL, EMPNO, ENAME, D.DEPTNO, DNAME, LOC
    FROM EMP E, DEPT D
    WHERE E.DEPTNO = D.DEPTNO
    AND SAL >= 3000
    ORDER BY D.DEPTNO;

-- ANSI 조인
SELECT EMPNO, ENAME, D.DEPTNO, DNAME, LOC
    FROM EMP E JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO
    WHERE E.DEPTNO = 10
    ORDER BY D.DEPTNO;
-- 급여가 3000 이상인 조건
SELECT SAL, EMPNO, ENAME, D.DEPTNO, DNAME, LOC
    FROM EMP E JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO
    WHERE SAL >= 3000
    ORDER BY D.DEPTNO;

-- EMP 테이블 별칭을 E로, DEPT 테이블 별칭은 D로 하여 다음과 같이 등가 조인을 했을 때 
-- 급여가 2500 이하이고 사원 번호가 9999 이하인 사원의 정보가 출력되도록 작성

-- 오라클 조인
SELECT EMPNO, ENAME, SAL, E.DEPTNO, DNAME, LOC -- DEPTNO는 동일하니까 한쪽에서만 선택해야 함
    FROM EMP E, DEPT D
    WHERE E.DEPTNO = D.DEPTNO   -- 동등 조인, 이너 조인(두 테이블이 일치하는 데이터만 선택)
    AND SAL <= 2500
    AND E.EMPNO <= 9999
    ORDER BY EMPNO;

-- ANSI
SELECT EMPNO, ENAME, SAL, E.DEPTNO, DNAME, LOC
    FROM EMP E JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO
    WHERE SAL <= 2500
    AND EMPNO <= 9999
    ORDER BY EMPNO;

-- 비등가 조인: 동일 컬럼(열)이 없는 경우 다른 조건으로 조인할 때 사용 (일반적인 경우는 아님)
SELECT * FROM EMP;
SELECT * FROM SALGRADE;

SELECT E.ENAME, E.SAL, S.GRADE
FROM EMP E, SALGRADE S      -- 두개의 테이블을 연결
WHERE E.SAL             
BETWEEN S.LOSAL AND S.HISAL; -- LOSAL 과 HISAL 의 범위 사이에서 SAL 지정
                             -- 비등가 조인
-- ANSI 조인으로 변경
SELECT ENAME, SAL, GRADE
FROM EMP E JOIN SALGRADE S
ON SAL BETWEEN LOSAL AND HISAL; 

-- 자체 조인: SELF JOIN. 같은 테이블을 두번 사용하여 자체 조인할 때
-- EMP 테이블에서 직속상관의 사원번호는 MGR에 있음
-- MGR을 이용해서 상관의 이름을 알아내기 위해 사용할 수 있음
SELECT E1.EMPNO, E1.ENAME, E1.MGR, 
    E2.EMPNO AS MGR_EMPNO,
    E2.ENAME AS MGR_ENAME 
    FROM EMP E1, EMP E2     -- 자체 조인은 같은 EMP 테이블을 두번 조인하는 것
WHERE E1.MGR = E2.EMPNO;    

-- 외부 조인: 동등 조인의 경우 한 쪽의 컬럼이 없는 경으면 해당 행은 표시 되지 않음
-- 외부 조인은 내부 조인과 다르게 다른 한쪽의 값이 없어도 출력 됨
-- 외부 조인은 동등 조인 조건을 만족하지 못해 누락되는 행을 출력하기 위함

INSERT INTO EMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
    VALUES(9000, 'NAME1', 'SALESMAN', 7698, SYSDATE, 1500, 500, NULL);
--  행 추가
SELECT * FROM EMP;

-- 
SELECT ENAME, E.DEPTNO, DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO -- 기준이 없으면 DEPTNO가 NULL인 새로운 행은 삭제
ORDER BY E.DEPTNO;


-- 왼쪽 외부 조인 사용하기 
SELECT ENAME, E.DEPTNO, DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO(+) -- 왼쪽 기준으로 오른쪽을 채운다. LEFT OUTER JOIN
ORDER BY E.DEPTNO;

-- 오른쪽 외부 조인 사용하기
SELECT E.ENAME, E.DEPTNO, D.DNAME, D.DEPTNO
FROM EMP E, DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO  -- 오른쪽 기준으로 왼쪽을 채움. RIGHT OUTER JOIN
ORDER BY E.DEPTNO;




-- SQL-99 표준문법으로 배우는 ANSI 조인
-- NATURAL JOIN: 등가 조인 대신 사용, 자동으로 같은 열을 찾아서 조인 해줌
SELECT EMPNO, ENAME, DNAME
FROM EMP NATURAL JOIN DEPT;

-- JOIN ~ USING : 등가조인 대신 사용. USING 키워드에 조인 기준 열을 명시하여 사용 
SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, DEPTNO
FROM EMP E JOIN DEPT D USING(DEPTNO)
ORDER BY DEPTNO;

-- JOIN ON : ANSI 등가 조인
SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, E.DEPTNO -- 기준 필요
FROM EMP E JOIN DEPT D 
ON E.DEPTNO = D.DEPTNO
ORDER BY DEPTNO;

-- ANSI LEFT OUTER JOIN
SELECT E.ENAME, E.DEPTNO, D.DNAME, D.DEPTNO
FROM EMP E LEFT OUTER JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
ORDER BY E.DEPTNO;

-- ANSI RIGHT OUTER JOIN
SELECT E.ENAME, E.DEPTNO, D.DNAME, D.DEPTNO
FROM EMP E RIGHT OUTER JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
ORDER BY E.DEPTNO;



-- 예제
-- 1.
SELECT E.DEPTNO , EMPNO, ENAME, DNAME, SAL
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
AND SAL > 2000
ORDER BY DEPTNO;

SELECT EMPNO, ENAME, DNAME, E.DEPTNO, SAL
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
AND SAL > 2000
ORDER BY DEPTNO;
-- 2.
SELECT D.DEPTNO, DNAME, TRUNC(AVG(SAL)), MAX(SAL), MIN(SAL), COUNT(*)
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
GROUP BY E.DEPTNO, D.DEPTNO, DNAME
ORDER BY DEPTNO;

SELECT DEPTNO,
       D.DNAME,
       TRUNC(AVG(SAL)) AS AVG_SAL,
       MAX(SAL) AS MAX_SAL,
       MIN(SAL) AS MIN_SAL,
       COUNT(*) AS CNT
  FROM EMP E JOIN DEPT D USING (DEPTNO)
GROUP BY DEPTNO, D.DNAME;

-- 3.
SELECT E.DEPTNO, DNAME, ENAME, JOB, SAL
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY DEPTNO, ENAME;

SELECT E.DEPTNO, DNAME, ENAME, JOB, SAL
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
ORDER BY DEPTNO, ENAME;




-- 서브 쿼리: 어떤 상황이나 조건에 따라 변할 수 있는 데이터값을 비교하기 위해 SQL문 안에 
-- 쿼리문을 새롭게 작성하는 SELECT문
SELECT DNAME FROM DEPT
WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME = 'KING');
-- 킹이라는 이름의 사원의 부서 이름을 찾기 위한 쿼리문

-- JONES 사원의 급여 보다 높은 급여를 받는 사원 정보 출력
SELECT * FROM EMP
WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME = 'JONES');
-- 존스의 급여
SELECT SAL FROM EMP
WHERE ENAME = 'JONES';


-- 문제
-- EMP 테이블의 사원 정보 중애서 사원 이름이 ALLEN인 사원의 추가 수당 보다 큰 많은 수당을 
-- 받는 사원 출력
SELECT COMM, ENAME FROM EMP
WHERE COMM > (SELECT COMM  FROM EMP WHERE ENAME = 'ALLEN')
ORDER BY COMM;

-- 입사일이 제임스보다 먼저 입사한 사원 출력 
SELECT * FROM EMP
WHERE HIREDATE < (SELECT HIREDATE FROM EMP WHERE ENAME = 'JAMES');

-- 20번 부서에 속한 사원 중 전체 사원의 평균 급여보다 높은 사람, 사원 정보와 소속 부서
SELECT EMPNO, ENAME, JOB, SAL, D.DEPTNO , DNAME, LOC
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
WHERE E.DEPTNO = 20
AND SAL > (SELECT AVG(SAL) FROM EMP);

-- 다중행 서브 쿼리 : 서브 쿼리의 실행 결과 행이 여러 개로 나오는 서브 쿼리
-- IN : 메인 쿼리의 데이터가 서브쿼리의 결과 중 하나라도 일치하면 TRUE
-- 각 부서별 최대 급여와 동일한 급여를 받는 사원 정보를 출력
SELECT * FROM EMP
WHERE SAL IN (SELECT MAX(SAL) 
                FROM EMP
                GROUP BY DEPTNO);

-- ANY 하나라도 만족하면 출력. 메인쿼리의 비교조건이 서브 쿼리의 여러 검색 
-- 결과 중 하나 이상 만족되면 반환
SELECT * FROM EMP
WHERE SAL = ANY (SELECT MAX(SAL) 
                FROM EMP
                GROUP BY DEPTNO);

SELECT EMPNO, ENAME, SAL, JOB
FROM EMP
WHERE SAL > ANY (SELECT SAL FROM EMP WHERE JOB = 'SALESMAN');
-- SELECT SAL FROM EMP WHERE JOB = 'SALESMAN': 이 조건은 5명이 출력되고 최소는 1250이므로
-- 1250보다 크기만 하면 출력,
-- IN 이었으면 SALESMAN이 포함된 결과를 출력


-- 30번 부서 사원들의 급여보다 적은 급여를 받는 사원의 정보 출력
-- ALL: 모든 조건을 만족한 경우에 성립
SELECT * 
FROM EMP
WHERE SAL < ALL(SELECT SAL
                FROM EMP
                WHERE DEPTNO = 30);

SELECT EMPNO, ENAME, SAL 
FROM EMP
WHERE SAL > ALL(SELECT SAL
                FROM EMP
                WHERE JOB = 'MANAGER');


-- EXISTS : 서브 쿼리의 결과값이 하나 이상 존재하면 조건식이 모두 TRUE, 존재하지 않으면 모두 FALSE
SELECT * 
FROM EMP
WHERE EXISTS (SELECT DNAME FROM DEPT WHERE DEPTNO = 10);


-- 다중열 서브 쿼리 : 서브쿼리의 결과가 두 개 이상의 컬럼으로 반환되어 메인 쿼리에 전달하는 쿼리
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, SAL FROM EMP WHERE DEPTNO = 30);

-- GROUP BY 절이 포함된 다중열 서브 쿼리 
SELECT * FROM EMP
WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO);
