-- from 절에서 사용하는 서브쿼리 : 인라인 뷰
-- from 절에서 직접 테이블을 명시하여 사용하기에는 테이블 내 데이터 규모가 큰 경우 사용
-- 보안이나 특정 목적으로 정보를 제공하는 경우
-- 10번 부서에 해당하는 테이블만 출력
SELECT E10.EMPNO, E10.ENAME, E10.DEPTNO, D.DNAME, D.LOC 
-- 인라인 뷰
FROM (SELECT * FROM EMP
        WHERE DEPTNO = 10) E10 JOIN(SELECT * FROM DEPT) D
ON E10.DEPTNO = D.DEPTNO; 

-- 먼저 정렬하고 해당 개수만 가져오기
-- ROWNUM: 오라클에서 제공하는 문법으로 행번호를 자동으로 매겨 줌
-- ORDER BY 절은 실행 순서의 마지막. 따라서, 상위 3개만 출력하기 위해서는 인라인 뷰가 필요
-- 정렬된 결과에서 상위 3개를 뽑을려면 테이블을 가져올 때 정렬된 상태로 가져와야 함.
-- 일반적인 SELECT 문에서 ORDER BY절은 마지막에 수행
SELECT ROWNUM, ENAME, SAL
FROM (SELECT * FROM EMP
        ORDER BY SAL DESC)
    WHERE ROWNUM <= 3;

-- SELECT 절에 사용하는 서브 쿼리 : 단일행 서브 쿼리. 스칼라 서브쿼리라고 한다
-- 반드시 하나의 결과만 나온다
SELECT EMPNO, ENAME, JOB, SAL, 
(SELECT GRADE FROM SALGRADE WHERE E.SAL BETWEEN LOSAL AND HISAL) AS 급여등급,
DEPTNO, 
(SELECT DNAME FROM DEPT WHERE E.DEPTNO = DEPT.DEPTNO) AS DNAME 
 FROM EMP E;

-- 예제
-- 매 행마다 부서번호가 각 행의 부서번호와 동일한 사원들의 SAL 평균을 구해서 반환
SELECT ENAME, DEPTNO, SAL,
(SELECT TRUNC(AVG(SAL)) FROM EMP WHERE DEPTNO = E.DEPTNO) AS 부서별평균급여
FROM EMP E;

-- 부서위치가 NEW YORK 인 경우 본사로, 그 외는 분점으로 반환
SELECT ENAME, EMPNO,
    CASE WHEN DEPTNO = (SELECT DEPTNO FROM DEPT WHERE LOC = 'NEW YORK') 
            THEN '본사'
            ELSE '분점'
        END AS 소속
FROM EMP
ORDER BY 소속;


-- 문제 
-- 1.
SELECT JOB, EMPNO, ENAME, SAL, E.DEPTNO, D.DNAME
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
AND JOB = (SELECT JOB FROM EMP WHERE ENAME = 'ALLEN');

-- 2.
SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.DNAME, LOC, SAL, GRADE
FROM EMP E
JOIN DEPT D ON E.DEPTNO = D.DEPTNO
JOIN SALGRADE S ON E.SAL BETWEEN S.LOSAL AND S.HISAL
WHERE E.SAL > (SELECT AVG(SAL) FROM EMP)
ORDER BY E.SAL DESC, E.EMPNO;

SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.DNAME, LOC, SAL, GRADE
FROM EMP E

-- 3.
SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.DNAME, LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
AND E.DEPTNO = 10 AND E.JOB NOT IN(SELECT DISTINCT JOB FROM EMP WHERE DEPTNO = 30);

-- 4.
-- 내가 푼 방식
SELECT EMPNO, ENAME, SAL, 
(SELECT GRADE FROM SALGRADE WHERE SAL BETWEEN LOSAL AND HISAL)
FROM EMP
WHERE SAL > (SELECT mAX(SAL) FROM EMP WHERE JOB = 'SALESMAN');

-- 다중행을 사용하지 않는 방식
SELECT E.EMPNO, E.ENAME, E.SAL, S.GRADE
  FROM EMP E, SALGRADE S
 WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
   AND SAL > (SELECT MAX(SAL)
                FROM EMP
               WHERE JOB = 'SALESMAN')
ORDER BY E.EMPNO;

-- 다중행을 사용
SELECT E.EMPNO, E.ENAME, E.SAL, S.GRADE
  FROM EMP E, SALGRADE S
 WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
   AND SAL > ALL (SELECT SAL
                    FROM EMP
                   WHERE JOB = 'SALESMAN')
ORDER BY E.EMPNO;


-- DML(DATA MANUOUALTION LANGUAGE) : 
-- 데이터를 조회(SELECT), 삭제(DELETE), 입력(INSERT), 변경(UPDATE)
-- 테이블이 아니고 데이터를 조작하는 것.

-- DML을 하기 위해서 임시 테이블을 생성
-- 기존의 DEPT 테이블을 복사해서 DEPT_TABLE 생성
CREATE TABLE DEPT_TEMP AS SELECT * FROM DEPT;
SELECT * FROM DEPT_TEMP;
DROP TABLE DEPT_TEMP; -- 테이블 삭제

-- 테이블에 데이터를 추가하기 
INSERT INTO DEPT_TEMP(DEPTNO, DNAME, LOC) VALUES(50, 'DATABASE', 'SOEUL');
INSERT INTO DEPT_TEMP(DEPTNO, LOC, DNAME) VALUES(50, 'SUWON', 'DEV');
INSERT INTO DEPT_TEMP(DEPTNO, LOC, DNAME) VALUES(70, 'BUSAN', NULL);
UPDATE DEPT_TEMP SET DEPTNO = 60 WHERE LOC = 'SUWON';
-- 테이블에 데이터를 추가하기.02
INSERT INTO DEPT_TEMP VALUES(80, 'FRONTEND', NULL);
INSERT INTO DEPT_TEMP VALUES(90, 'BACKEND'); -- 오류, 열의 갯수가 맞지 않음
INSERT INTO DEPT_TEMP(DEPTNO, DNAME) VALUES(90, 'BACKEND'); -- 이건 된다. 2개만 지정하겠다고 명시

-- 테이블 복사하기.02
CREATE TABLE EMP_TEMP AS SELECT * FROM EMP 
WHERE 1 != 1; -- 1 != 1 : 모든 조건이 부정. 따라서 테이블의 모든 내용을 지우고 빈 테이블을 복사
SELECT * FROM EMP_TEMP;
-- 날짜 정보 입력하기
INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
    VALUES(9001, '나영석', 'PRESIDENT', NULL, SYSDATE, 2000, 1000, 10);
INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
    VALUES(9002, '안유진', 'MANAGER', 9000, TO_DATE('2023/09/19', 'YYYY/MM/DD'), 2000, 1000, 10); 
INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
    VALUES(9003, '카리나', 'MANAGER', 9000, TO_DATE('2023/09/07', 'YYYY/MM/DD'), 2000, 1000, 10); 
-- 서브쿼리를 이용한 INSERT 
INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO
FROM EMP E JOIN SALGRADE S
ON E.SAL BETWEEN S.LOSAL AND S.HISAL
WHERE S.GRADE = 1;

-- UPDATE: 행의 정보를 변경할 때 사용
-- UPDATE 테이블 이름 SET 변경할 열의 이름과 데이터 WHERE 조건식
SELECT * FROM DEPT_TEMP02;    
CREATE TABLE DEPT_TEMP02 AS SELECT * FROM DEPT_TEMP;
-- WHERE 없이 사용
UPDATE DEPT_TEMP02 SET DNAME = NULL;  
-- WHERE 사용
UPDATE DEPT_TEMP02 SET DNAME = 'DB' WHERE DEPTNO = 20;
UPDATE DEPT_TEMP02 SET DNAME = 'DB', LOC = 'INCHONE' WHERE DEPTNO = 30;

-- DELETE : 테이블에 있는 데이터를 삭제하기
DROP TABLE EMP_TEMP02;
CREATE TABLE EMP_TEMP02 AS SELECT * FROM EMP_TEMP;
SELECT * FROM EMP_TEMP02;
-- 조건절없이 DELETE하면 모든 데이터 삭제
DELETE FROM EMP_TEMP02;
-- 조건절이 있는 경우
DELETE FROM EMP_TEMP02
WHERE JOB = 'MANAGER';  




-- 트랜잭션
-- 연습용 테이블 생성
CREATE TABLE DEPT_TCL AS SELECT * FROM DEPT;
SELECT * FROM DEPT_TCL;
INSERT INTO DEPT_TCL VALUES(50, 'DATA', 'SOEUL');
COMMIT;

UPDATE DEPT_TCL SET LOC = 'SEOUL'
WHERE DEPTNO = 30;